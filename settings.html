<!DOCTYPE HTML>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />		
	<title>appledoc @ GitHub</title>
	<link rel="stylesheet" type="text/css" media="screen" href="styles.css"  />
</head>

<body>
	<article id="contents" role="main">
		<div id="header">
			<div id="download">
			  <a href="http://github.com/tomaz/appledoc/zipball/master">
			    <img width="90" src="http://github.com/images/modules/download/zip.png"></a>
			  <a href="http://github.com/tomaz/appledoc/tarball/master">
			    <img width="90" src="http://github.com/images/modules/download/tar.png"></a>
			</div>
			<a href="http://github.com/tomaz/appledoc"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>
			<h1>appledoc</h1>
			<p>Objective-C documentation set generator.</p>
		</div>
		<div id="container">
			<a name="settings"></a>
			<h2>Settings and parameters</h2>
			<p>appledoc has been designed to keep the command line as simple as possible. On the other hand, it offers many command line swithces as parameters for you to refine generated output. However only a handful of these parameters are unique from project to project, most of them are common to many projects - company name, documentation set information, etc. To strike the balance, appledoc uses sensible defaults plus it allows you specify common parameters as global settings. In fact, there are three layers of settings:
			<ul>
				<li>Factory defaults: These are "hard-wired" into appledoc code and are designed to be as reusable as possible.</li>
				<li>Global settings: Some of the defaults cannot be pre-configured, but are ussually common to many of the projects; company name for example. Global settings override factory defaults.</li>
				<li>Command line arguments: You can override factory defaults and global settings through command line arguments.</li>
			</ul>
			You can change all parameters provided by appledoc through any of the above mentioned layers. To discover what settings are available, use: <pre>appledoc --help</pre> Most switches require a parameter of certain type as indicated in help output. Boolean switches don't use parameter on the other hand; they can be prefixed with <code>--no-</code> string to opt them out; see appledoc help output to identify these switches. This is especially useful to disable factory default or global setting. For example: to enable doc set installation, you would use <code>--install-docset</code>, and to disable it: <code>--no-install-docset</code>.
			</p>
			
			
			<a name="globals"></a>
			<h2>Global settings</h2>
			<p>Global settings are configured through a standard plist file. The path of the global settings file is specified through <code>--templates</code> command line switch - the same switch is used for giving the path to the template files used for generating output (HTML and CSS files for example). So global settings file is located at the same path as template files. As it would be tedious to specify this path for every run, appledoc uses two predefined paths for locating these files:
			<ul>
				<li>~/Library/Application Support/appledoc</li>
				<li>~/.appledoc</li>
			</ul>
			The paths are searched in the given order - if both exist, the first one will be used. If none of these paths exist, or you want to specify another path, you must use <code>--templates</code> command line argument. If a file with a name <code>GlobalSettings.plist</code> exists in the template path used (either one of the predefined paths or the path from command line), it is loaded and any valid settings found are used for overriding factory defaults.</p>
			<p>Global settings use exactly the same arguments as command line, so you don't have to remember another set of keys! Use <code>appledoc --help</code> to see the list of all possible keys. However due to the way plists work, there are few simple rules:
			<ul>
				<li>Settings that can be passed multiple times (<code>--ignore</code> for example) should be specified as an array under a single key with the name of the settings.</li>
				<li>Boolean settings should be given in their "normal" form and their value specified with either true or false value (i.e. there's no need to use <code>--no-</code> prefix).</li>
				<li>All other settings should be strings or numbers - depending the value, check <code>appledoc --help</code> for details.</li>
			</ul>
			An example of the plist file:
<pre>&lt;?xml version="1.0" encoding="UTF-8"&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
	"http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
	&lt;key>--ignore&lt;/key&gt;
	&lt;array&gt;
		&lt;string>ThirdParty&lt;/string&gt;
		&lt;string>Libraries&lt;/string&gt;
		&lt;string>Frameworks&lt;/string&gt;
		&lt;string>Testing&lt;/string&gt;
	&lt;/array&gt;
	&lt;key>--project-company&lt;/key&gt;
	&lt;string>Gentle Bytes&lt;/string&gt;
	&lt;key>--company-id&lt;/key&gt;
	&lt;string>com.gentlebytes&lt;/string&gt;
	&lt;key>--create-docset&lt;/key&gt;
	&lt;true/&gt;
	&lt;key>--install-docset&lt;/key&gt;
	&lt;false/&gt;
	&lt;key>--verbose&lt;/key&gt;
	&lt;integer>4&lt;/integer&gt;
	&lt;key>--logformat&lt;/key&gt;
	&lt;integer>1&lt;/integer&gt;
&lt;/dict&gt;
&lt;/plist&gt;</pre>
			Most commonly used global settings include <code>--project-company</code>, <code>--company-id</code>, <code>--verbose</code>, <code>--logformat</code> and similar. These are all settings that are ussually constant between the projects and would otherwise require repeating command line swithces on everry run. Of course you can still override them on specific projects if needed!</p>
			
			
			<a name="placeholders"></a>
			<h2>Settings placeholder strings</h2>
			<p>To avoid repetition and simplify command line interface even further, many settings allow you to specify placeholder strings that are replaced with actual settings values. Commonly used placeholders are:
			<ul>
				<li><code>%PROJECT</code>: Replaced with the value of <code>--project-name</code>.</li>
				<li><code>%PROJECTID</code>: Replaced with normalized value of <code>--project-name</code>.</li>
				<li><code>%COMPANY</code>: Replaced with the value of <code>--project-company</code>.</li>
				<li><code>%COMPANYID</code>: Replaced with the value of <code>--company-id</code>.</li>
				<li><code>%VERSION</code>: Replaced with the value of <code>--project-version</code>.</li>
				<li><code>%VERSIONID</code>: Replaced with normalized value of <code>--project-version</code>.</li>
				<li><code>%YEAR</code>: Replaced with current year in format <code>yyyy</code>.</li>
				<li><code>%UPDATEDATE</code>: Replaced with current date in format <code>yyyy-MM-dd</code>.</li>
			</ul>
			Normalized values are actual strings where all whitespace is replaced with minus signs. So "My Great Project" would become "My-Great-Project".</p>			
			<p>Other available placehoders are (<strong>Note:</strong> Due to the usage of above mentioned placeholders as default values you should rarely if ever need supply custom values through command line - default values should result in sensible results! However all customization nuts, knock yourself out :)):
			<ul>
				<li><code>%DOCSETBUNDLEFILENAME</code>: Replaced with the value of <code>--docset-bundle-filename</code>. Defaults to 
					<span class="value">%COMPANYID.%PROJECTID.docset</span>, which results into something like 
					<span class="value">com.gentlebytes.appledoc.docset</span>.</li>
				<li><code>%DOCSETATOMFILENAME</code>: Replaced with the value of <code>--docset-atom-filename</code>. Defaults to 
					<span class="value">%COMPANYID.%PROJECTID.atom</span>, which results into something like 
					<span class="value">com.gentlebytes.appledoc.atom</span>.
				</li>
				<li><code>%DOCSETPACKAGEFILENAME</code>: Replaced with the value of <code>--docset-package-filename</code>. Defaults to 
					<span class="value">%COMPANYID.%PROJECTID-%VERSIONID.xar</span>, which results into something like 
					<span class="value">com.gentlebytes.appledoc-2.0.xar</span>.
				</li>
			</ul>
			If you're wondering why these placeholders exist, they come extremly handy when <a href="#publishDocSet">preparing documentation set for publishing</a>.</p>
			<p>All settings that can use these placeholders are marked in help output by running <code>appledoc --help</code>. This works regardless of whether the setting value came from factory defaults, global setting or command line switch!</p>
			
			
			
			<h2>Basic command line examples</h2>
			<div class="cmdlineexamplesection">
				<p>Find some examples of command line usage below. Each command line switch is written in it's own line to make the output more readable; switches should be delimited with space normally!</p>
				
				<a name="minimumCmdLine"></a>
				<h3>Minimum command line</h3>
				<p>
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
.</pre>
				Parses files from current directory and generates HTML files in the given output path. HTML files are then used to generate documentation set (in given output path) and this is finally moved to shared folder where Xcode searches documentation sets. Xcode is also instructed to reload documentation, so any change is immediately visible.</p>
				
				
				<a name="multipleSourcesCmdLine"></a>
				<h3>Parsing from multiple locations</h3>
				<p>All command line arguments after the last switch are considered as source paths. Each path is validated and as long as all are valid directory or file names, appledoc uses them for parsing. If the path is directory, it's recursively parsed for all source files. If path is file, it's parsed as source file:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
~/Projects/Common
~/Projects/Frameworks/SomeHeader.h
~/Projects/Frameworks/AnotherFile.m
.</pre>
				This extends previous example by including all files from ~/Projects/Common directory and it's subdirectories and ~/Projects/Frameworks/SomeHeader.h and ~/Projects/Frameworks/AnotherFile.m files besides the files from current directory.</p>			
				<p>This allows you to include files regardless of where they reside on your computer. For example, it may be used to include headers from frameworks or libraries your project uses or simply to only parse a subset of your project files.</p>
				
				
				<a name="ignoreCmdLine"></a>
				<h3>Ignore paths</h3>
				<p>You can instruct appledoc to ignore any number of paths or files using <code>--ignore</code> switches. This is useful if your project includes third party source files for example (it's much easier to put these files into a subfolder to simplify ignoring):
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/Projects/Help/appledoc
--ignore Common
--ignore .m
.</pre>
				Using this command line would effectively ignore all files in ./Common including all subdirectories. Additionally it would ignore all files and directories with extension .m.</p>
				<p>Each --ignore switch takes a single path that should be ignored while parsing. It works very simply: each directory or file found in the given source paths (. in this case) is checked and if it ends with one of the ignore values, the path is skipped. Or put in other words: <code>[NSString hasSuffix:]</code> is sent to each source file or directory to validate ignored files.</p>
				<p><strong>Important:</strong> Note that --ignore strings don't accept * and ? chars for unknown chars matching! However if the string starts with a star (*), the star is removed, so <code>--ignore *.m</code> is internally translated to <code>--ignore .m</code> for your convenience. But star in the middle doesn't work, so this <code>--ignore path/subpath/*.m</code> would not ignore all .m files in path/subpath as expected - in fact, it would only match files or directories which names end with path/subpath/*.m!</p>				
			</div>
			
			
			<h2>Advanced command line examples</h2>
			<div class="cmdlineexamplesection">
			<p>This section contains additional examples and descriptions of command line switches which usage may not be immediately obvious.</p>
			
				<a name="publishDocSet"></a>
				<h3>Prepare documentation set for publishing</h3>
				<p>appledoc can prepare documentation set for publishing too, just add <code>--publish-docset</code>, <code>--docset-feed-url</code> and <code>--docset-package-url</code> switches to command line like this:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/Projects/Help/appledoc
--docset-feed-url http://gentlebytes.com/downloads/%DOCSETATOMFILENAME
--docset-package-url http://gentlebytes.com/downloads/%DOCSETPACKAGEFILENAME
--publish-docset 
.</pre>
				This command line will create and install documentation set and finally run docsetutil over installed docset to create compressed documentation set file and atom feed you can upload to your server. Both files are saved to <code>publish</code> subdirectory within <code>--output</code> path. You can then pass them to <code>rsync</code> or similar tool for actually uploading to your server (although command line switch may suggest so, appledoc doesn't do uploading itself, it only generates necessary files!). When uploading, make sure the files are available at the URLs given to <code>--docset-feed-url</code> and <code>--docset-package-url</code>! You can use <a href="#miscellaneousCmdLine"><code>--print-settings</code></a> command line switch to have appledoc print the actual URLs after replacing <a href="#placeholders">template placeholders</a>.</p>
				<p><strong>Important:</strong> When you increment versions, the atom file needs to be updated properly - a new entry needs to be inserted for each new version. To allow that, appledoc checks if the atom file already exists at output path. If so, the existing file is updated with new information by docsetutil. First the file is parsed and if an entry is found corresponding to <code>--project-version</code>, the entry is updated. If no entry matching the version is found, a new entry is added to the file. Therefore it is important to keep the generated atom file at output path (you can safely remove package (.xar file) after uploading though)! In fact, this is the mechanism used by appledoc to have the atom file updated with new versions, so keep that in mind!</p>
				<p><strong>Note:</strong> Notice the usage of <code>%DOCSETATOMFILENAME</code> and <code>%DOCSETPACKAGEFILENAME</code> placeholders for command line switches - it is <a href="#placeholders">recommended to use these</a> to keep the actual filenames in sync with information written to atom file!</p>
				<p><strong>Note:</strong> You can also include <code>--docset-fallback-url</code> so that Xcode can get to your documentation installed on remote server. The location given should point to the contents of your DocSet <code>Documents</code> folder (at present appledoc doesn't prepare a copy of this folder, you can find it either at <code>--docset-install-path</code> (if you use default value, add <a href="#miscellaneousCmdLine"><code>--print-settings</code></a> command line switch to have it printed for you) or alternatively use <code>--keep-intermediate</code> and find the files at your <code>--output</code> location).</p>


				<a name="undocumentedCmdLine"></a>
				<h3>Undocumented objects and members handling</h3>
				<p>By default appledoc ignores all undocumented classes, categories, protocols as well as methods and properties. However you can instruct it to include undocumented objects and members in generated HTML:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/Projects/Help/appledoc
--keep-undocumented-objects
--keep-undocumented-members
--search-undocumented-doc
.</pre>
				This command line would include every parsed object (class, category and protocol) and it's member (method or property). Additionally it would search for documentation of undocumented members in super classes and adopted protocols. To better understand how these switched interact with each other this is the workflow used:
				<ul>
					<li>If <code>--search-undocumented-doc</code> is enabled, all undocumented methods and properties documentation is searched for in known super class hierarchy. If documentation is found in any of the super classes, it is copied to inherited member as well. If documentation is not found in superclasses, it is searched for in adopted protocols and copied from there if possible. If disabled, members are left undocumented and are handled that way as described below. This option is enabled by default (in fact above example doesn't need to enable it explicitly); to disable, use <code>--no-search-undocumented-doc.</code></li>
					<li>If <code>--keep-undocumented-members</code> is enabled, all undocumented methods and properties are left and used for output. If disabled, any undocumented method or property is removed from class (of course any documentation copied over from super classes or adopted protocols in previous step is considered valid too). This option is disabled by default.</li>
					<li>If <code>--keep-undocumented-objects</code> is enabled, all undocumented classes, categories and protocols are left. If disabled, all undocumented objects that have no documented method or property are also removed. However if undocumented object contains documented members, the object is left and used for output regardless of this option (overview section would be ommited in generated HTML)! This option is disabled by default.</li>
				</ul></p>
				
				
				<a name="mergeCmdLine"></a>
				<h3>Merging category documentation</h3>
				<p>Apple seems to merge categories documentation to it's class to keep it together and appledoc is configured to do the same:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--merge-categories
.</pre>
				This command line will merge categories and extension documentation to their classes as long as the class is also found in the given source files. In fact, this behavior is enabled by default, so you can skip <code>--merge-categories</code> switch in the above example and get the same result. You can refine how categories are merged with two additional switches:
				<ul>
					<li><code>--keep-merged-sections</code>: If enabled, all <a href="comments.html#misc">@name sections</a> from categories are preserved, otherwise all methods from category are merged into a single section using category name as section title. This is disabled by default as this seems to be how Apple does it. Enabling this option may result in fragmented class documentation, so experiment a bit to see what works best for you.</li>
					<li><code>--prefix-merged-sections</code>: If enabled, all merged category section titles are prefixed with category name, otherwise original title is left. This is disabled by default, but you can enable it if it suits you better - again, experiment to see what works for you. This switch is ignored unless <code>--keep-merged-section</code> is enabled! <strong>Important:</strong> extension sections are never prefixed regardless of this setting!</li>
				</ul>
				Both switches are ignored if categories merging is disabled (i.e. <code>--no-merge-categories</code>!</p>



				<a name="crossrefsdetection"></a>
				<h3>Controlling cross references detection</h3>
				<p>By default any valid cross reference word or URL, optionally embedded within <code>&lt;&gt;</code> markers is converted to cross reference link in resulting documentation. Although this greatly simplifies cross references handling, it may lead to unexpected links. For example if one of your methods or properties has selector <code>paragraph</code>, every word <em>paragraph</em> is converted to cross reference to that method. To give you control over which word should be converted to cross reference and which shouldn't, appledoc allows you to turn on explicit cross references like this:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--explicit-crossref
.</pre>
				This command line will check cross references only in words embedded with <code>&lt;&gt;</code> markers. This gives you control over which word should be converted to cross references and which not, but requires you to use additional syntax; above example would need to be written as <code>&lt;paragraph&gt;</code>. Note: without explicit cross references option, you can still embed words with <code>&lt;&gt;</code> markers - this is optional by default, but with explicit option, markers are required!</p>
				
				<p>Further more, if you don't like default markers, you can use arbitrary ones for embedding cross references in your code. This is great for porting your code from other documenting systems. Here's an example:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--crossref-format "#%@#"
.</pre>
				This example would only check for cross references embedded within <code>##</code> markers, for example <code>#paragraph#</code>. Even more, <code>--crossref-format</code> takes regex expression, so you can become very creative. For example, to change markers to <code>#</code> and make them optional, you'd use <code>--crossref-format "#?%@#?"</code> instead. Make sure you don't forget to include <code>%@</code> placeholder - this is replaced with actual cross reference matching regexes for various types of links!</p>
				
				<p><strong>Important:</strong> Take care when specifying custom markers - make sure you don't use one of the <a href="comments.html#formatting">formatting markers</a> (<code>*</code>, <code>_</code> and similar); although appledoc will not warn you about it, results are unpredictable and either cross reference or format will not be recognized. Also make sure to not use capturing parenthesis (this is especially important for starting marker)! Cross references matching relies on exact capture group numbers for finding specific parts of reference (like object and method for remote members), so introducing new capturing parenthesis would break that! But you can use non-capturing parenthesis <code>(?:...)</code> if needed.</p>

				<p><strong>Note:</strong> <code>--crossref-format</code> and <code>--explicit-crossref</code> cmd line switches are mutually exclusive! Internally, appledoc uses <code>&lt;?%@&gt;?</code> for cross references matching, which makes markers optional. Using <code>--explicit-crossref</code> is equal to using <code>--crossref-format "&lt;%@&gt;"</code> and is in fact just a convenience shortcut for it! If you use both options in command line, the last one found will be used!</p>
				
				<p><strong>Note:</strong> Note that you must use quotes with <code>--crossref-format</code> even if no whitespace is included with the option!</p>
				
				
				
				<a name="inspectCmdLine"></a>
				<h3>Inspect generated HTML or documentation set files</h3>
				<p>appledoc output generation works in several steps (i.e. generate HTML, generate docset, install docset). Each step output files are used as source for next step. For performance reasons, files are moved instead of copied between these steps by default. Although this makes appledoc more efficient, it may seem strange to see output folder empty when appledoc finishes. If so, just think of --output switch as the path to temporary files used during generation. In most cases these intermediate files are not needed and are later removed manually anyway. However there are occasions where you'd want to inspect output; debugging or archiving for example. You can tell appledoc to copy instead of move like this:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--keep-intermediate-files
.</pre>
				Using this option all intermediate files (i.e. HTML and docset files, including docset description XML files) are kept in output path.</p>
				<p>Alternatively you can tell appledoc to only create HTML files:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--no-create-docset
.</pre>
				By adding <code>--no-create-docset</code> you instruct appledoc to create HTML and then quit. Using this command line, you'll find HTML files in ~/help/html.
				</p>
				<p>Similarly you can tell appledoc to create docset but not install it:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--no-install-docset
.</pre>
				Using this command line you'll find docset files in ~/help/docset. The docset is already indexed with all description xml files used for indexing left so you can inspect them. Note that in this case, html directory is moved inside ~/help/docset which effectively removes it from output path.</p>
				<p>You can also disable HTML files generation by using <code>--no-create-html</code> switch. This effectively disables any output generation and only invokes source code parsing and comments processing. As generation phase takes most time (typically more than 90%!), this option is useful for quick validation of your comments for unknown cross references and similar. It may come handy to include it as a regular build phase for larger targets to validate your comments and then manually invoke generation before releasing.</p>
							
			</div>
			
			
			<a name="miscellaneousCmdLine"></a>
			<h2>Various tips</h2>
			<div class="cmdlineexamplesection">
				<p>
				<ul>
					<li>You can use <code>--print-settings</code> option to print values of all settings used for the current session. Settings are printed after replacing <a href="#placeholders">placeholder values</a>, so this makes it perfect for getting various paths and similar. Or for debugging when things are not working according to your expectations. For example, it can save you hours of banging your head on a wall to only realize you've forgotten overriding some global setting (it sure saved our heads a lot :). This option has negligible affect to performance, so you can simply include it in your <a href="#globals">global settings</a> to avoid command line clutter.</li>
					<li>You can use <code>--repeat-first-par</code> option to enable or disable repeating first paragraph in methods and properties discussion section. By default appledoc repeats first paragraph, but you can disable it with <code>--no-repeat-first-par</code>. <strong>Important:</strong> Note that discussion section is omitted for methods or properties that only have a single paragraph, even if repeating is enabled!</li>
				</ul></p>
			</div>
		</div>
		<div id="aside">
			<h2>Contents</h2>
			<p>
			<ul>
				<li><a href="index.html">About</a></li>
				<li><a href="comments.html">Comments</a></li>
				<li><a href="settings.html">Settings</a></li>
			</ul>
			</p>
		</div>
		<div id="footer">
			&copy; 2009-2010 <a href="http://gentlebytes.com">Gentle Bytes</a>. All rights reserved.
		</div>
	</article>
	<script type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script>
	<script type="text/javascript">
	try {
	var pageTracker = _gat._getTracker("UA-11836532-1");
	pageTracker._trackPageview();
	} catch(err) {}</script>
</body>

</html>